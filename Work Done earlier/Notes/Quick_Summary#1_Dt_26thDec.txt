>Understood what exactly a process is, its creation and loading. fork and execve call.
>Studied about various UNIX system calls
>Understood that a.out < COFF < elf
>I learned Python and bash scripting
>Understood that ABI is a kind of API for machine level language
>Understood Importance of Makefile
>Read up about Little Endian and Big Endian
>Studied about environment variables and how to use them
>learned how to list symbols and also to delete them
>learned that .bashrc is run at the very first of a bash terminal
>learned how to see the current time virtual memory space of a executable
>learned the difference between statically linked and dynamically linked binary
>Read up about encryption

>Made programs 
>>to send email from terminal(python) and 
>>search among all the txt files in a directory for a particular keyword

>Studied about tools:
>>Valgrind
>>Memcheck (memory leaking)
>>Massif (nice visual graph showing allocation of memory in heap and stack)
>>GDB (binary debugging in a virtual environment)
>>Learning Prolog
>>Ghidra: Learned how to visualize code flow

>Read about Buffer Overflow that will be used in Task 3
>Applied how python commands can be run from echo

>from Task1 and 2 we learned:
>>How to generate random string
>>How to use tr
>>How to encrypt any file like a ransomware
>>basename and find command
>>Basically, we literally created a ransomware

>Reading book:
>>Linux Assembly Language Programming
>>Programming from the Ground UP 

Here the team work:

>Differentiated between Clang and GCC and understood how clang works (n+m rather than n*m complexity)
>Read up about readelf and its various sections like .text, .plt, .data, .init, .bss and .rodata , objdump, strace(useful when we don’t have the source code), ltrace and tried them hands on
>Done with Task 1, and Task2, working on Task1.1 (We literally created the behaviour of a ransomware)

>Task 2 Mod: created a .c file to replicate ransomware behaviour
>>Note: found Stack Smashing error while concatenating string. (response to its defence mechanism against buffer overflows(that might change the return address from the function).) can be exploited for the next tasks. Explanation
>>Stack grows downwards and heap grows upwards, but a buffer is filled upwards. Kernel resides in the highest address

>Studied Ghidra, GDB.
>Used Ghidra to reverse engineer a binary (like cracking the if conditions or changing the variable’s coded values).
>Learned and still learning bash scripting
>Used Ghidra for Decompilation a binary and study a rough behaviour of the binary
>Studied and applied GPG, openssl, and learned about tar.gz and zip files
>Learned shc tool to create binary of a sh file, but having it to work is still remaining

