Read about Clang And GCC and did the analysis of their performance based on Size of binary generated, execution time, No of variable used.
Make Gihub Repo
Learning Python
Valgrind
Heap sprays
Return Oriented Programming
Data Execution Prevention(DEP) defeats
read ASLR
Canary defeats
NX-bit defeats
Debuggers like GDB, Ghidra
Assembly Programming
Reverse Engineering
Buffer Overflow attack

Installation script
Memory Overflow script
Process of installation
Finding files and encrypt them and save enc keys somewhere
Connect automata theory here with how loops work(Theory of self-reproducing Automata)

Coredump
GDB to process Coredump

Invasion of Harddisk
Buffer Overflow and exploit this vulnerability
Running binary from SHC

Made program that can ignore the action of Ctrl+C
DDD tool
Write intermediate variable value to a file from GDB
Generate .exe, .iso, .deb files

Learned about base64 encryption
Content preserving hashing
Made Python executable
toolBox.sh
Article: Self Modifying Code and Experimenting with it(2013 Article)
Compile Assembly language into executable
Decompiling ELF back to source code(Ghidra)
Determining featuring signature of a file(making of toolBox.sh)
Brian Raitar portal(http://www.muppetlabs.com/~breadbox/software/tiny)
Giant-Black-Book-Computer-Viruses by Ludwig
The Little Black BookofComputer Viruses
Learning Linux Binary Analysis by Ryan O'Neill (The ELF Master)

read Checksum
Installing malware in .deb file
Execute gedit instead of shell in self-modifying code
Everything mentioned here https://docs.google.com/presentation/d/1ydwzPkGRj-GHkgVel8XgmlicOg0Cbq9a7Js9JbpyG9o/edit#slide=id.gc6fa3c898_0_0 on slide 13
Self reproducing automata
Cohen's Article
Unpack a .deb file and inject malware
Do the same with iso and exe

Singal desktop application Analysis

