This is a bit tricky crackme to do just with static analysis.
As the title says, it's about overflow, by having
a quick look into the `login` function in the binary.
We can see we allocate 2 blocks on the heap,
one is used for the user input,
and second one is used to actually decide if the user is admin or not. 
The second block has hardcoded value of 1,
so how do we change the hardcoded value?
We also see that the size of the buffer and
the maximum amount of chars possibly read by fgets differ a lot,
giving us the possibility to overflow the allocated block, buffer

If we step into the debugger, we can see that the 2 allocated blocks are just 32 bytes apart!
the first buffer (used for user input) has space for only 16 bytes, so 16 bytes is the extra space between
those 2 blocks (probably some malloc metadata).

Because the buffer we can overflow is before the buffer we need to change,
we can easily write over the bounds. But we need to have zero inside the second buffer,
how can we write a 0 with a writable ascii character? 
Well, if we look into the code, we can see that fgets is used to read the input,
we know that fgets read all the characters and then adds null terminator. 
So now it's simple, the input will be exactly 31 characters,
the fgets will then add the null terminator and overwrite 
the hardcoded 1 in the buffer and giving us the admin access!

