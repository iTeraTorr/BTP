->Exercise:
1. Write a program to generate spiral matrix?
Example: it should accept two inputs
A. Nr. of rows
B. Nr. of columns
spiral.c
spiral
$: ./spiral

Enter row count: m
Enter column count: n

Test Cases: 

m=n=1
1

m=1 n=2
1 2

m=1 n=2
1
2

m=2 n=2
1 2
4 3

not always necessary that m == n

m=2 n=3
1 2 3
6 5 4

m=n=3
123
894
765
------------------------
-------------------------------
-->Tasks(Compare Metrics of clang and gcc)
-->For instance, this could be:
-->1. Size of binary geenrated , Clang: 12592 ; GCC: 12784 (GCC > Clang)
-->2. Execution times of both executables, Clang: 0.0034674 s ; GCC: 0.0035372 s (almost same)
  But Compilation time of Clang is almost 1.5 times the compilation time of GCC
-->3. Nr. of variables used in both
-->4. Insight into the binaries with readelf and/or objdump etc
4--> GCC has __cxa_finalize@plt, clock@plt, clock@plt  as extra sections
-------------------------------
now you have multiple variants of a same algorithm. Do a comparative analysis, you can use valgrind tool for this.

1. https://valgrind.org/docs/manual/quick-start.html

2. Try other tools listed at:
https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C,_C++
----------------------------------  

Additional tasks:

1. Use Clang compiler (not GCC) try to do it for 1999, 2011 and 2017 standards
2. Then profile your programs for interesting metrics using the following tools:
a. https://www.valgrind.org/docs/manual/mc-manual.html
b. https://www.valgrind.org/docs/manual/ms-manual.html

-----------------------------------
------------------------
->Make Github repo of the project
->Take Notes on daily basis
->Have familiarity with:
1. Prolog(Sicstus Prolog: Very well documented prolog) ->Functional Language(Just provide what to do, you get control for free)
2. Rust
3. Python
->These all are interpretable language
->But always it is possible to compile

-> Learn Prolog, Python and Rust
-> Program = Logic + Control + Algorithm
-> Microprocessor = Registers + PC+ IR + ALU + CU + Accumulator
-> Programmer = SRS -> Analysis and Design -> Coding
-> Coding = Specify Logic + Specify Control
-> Logic = What needs to be done?
-> Control= How it needs to be done?
-> Prolog runtime: Interpreted

----------------------------

Project Specific Stuff:
->Analysis, design, and identify desired program behaviours
->Different software standards: MISRA-C, etc
->Pursue static and dynamic analysis applying the research tools of disassemblers, debuggers, and fuzzers.
->Reverse engineering skills in software(and/ or hardware) for the purpose of understanding and/or vulnerability discovery:
  ->Heap sprays(https://en.wikipedia.org/wiki/Heap_spraying)
  ->Return-oriented_programming(ROP) gadgets(https://en.wikipedia.org/wiki/Return-oriented_programming)
  ->Data Execution Prevention(DEP) defeats
  ->Address Space Layout Randomization(ASLR) defeats and KASLR defeats(https://en.wikipedia.org/wiki/Address_space_layout_randomization)
  ->CFG defeats(https://sites.google.com/site/bingsunsec/dataonlyattack)
  ->Canary value defeats(https://en.wikipedia.org/wiki/Buffer_overflow_protection#:~:text=Buffer%20overflow%20protection%20is%20any,from%20becoming%20serious%20security%20vulnerabilities, )
  ->NX-bit defeats(https://en.wikipedia.org/wiki/Executable_space_protection, https://en.wikipedia.org/wiki/NX_bit)
->Expertise in C, Assembly, and Python
->Advance in Windows/Linux/UNIX/MobileOS (Android)

Proceed:
->Gain experience in performing software vulnerability research
->Understand of low-level OS internals
->Learn reading and/or writing assembly(examples for various architecture: x86, x64, ARM, MIPS, SPARC, 68k, PPC, or others)
->Understanding of network protocols(TCP/IP stacks, wire level protocols, RF communication, BGP, routing protocols, or others) ->CBD
->Understand exploit mitigations of DEP, ASLR, etc.
->Learn reverse engineering tools such as : IDA Pro, Binary Ninja, Ghidra, Radare2, etc -> IMP
->Learn using debuggers such as: gdb, edb, WinDbg, OllyDbg, etc -> IMP
->Look into device drivers development -> CBD
->Gain expertise into (eg git, Atlassian, Jira, etc)

Minimum work VIMP:
1. Buffer overflow attack: Read https://www.coengoedegebure.com/buffer-overflow-attacks-explained/
and https://security.stackexchange.com/questions/20497/stack-overflows-defeating-canaries-aslr-dep-nx
2. http://hmarco.org/renewssp/data/OnTheEffectivness-NX-SSP-RenewSSP-and-ASLR-Slides.pdf
3. Heap spray: https://broken-stack.github.io/post/heapspray/
4. Goto:  https://iitiiot.bitbucket.io/



